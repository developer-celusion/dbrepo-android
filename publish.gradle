apply plugin: 'maven-publish'

// Modernized publish.gradle for AGP 8.13 / Gradle 8.13
// - Uses Provider APIs (layout.buildDirectory, tasks.named, etc.)
// - Includes Kotlin sources if present
// - Guards configurations and task lookups to avoid deprecation warnings
// - Sets Javadoc to failOnError = false and skips javadoc artifact on JitPack

// Adjust these to your coordinates
def packageName   = 'com.mobiliteam'
def libraryVersion = '0.5.7'
def appId         = 'dbrepo'

// detect JitPack environment so we can skip fragile tasks there if desired
// JitPack sets the JITPACK env var when running builds
def isJitpack = System.getenv('JITPACK') != null

/* ---------------- Javadoc / sources ---------------- */
// Register Javadoc task (lenient)
tasks.register('androidJavadocs', Javadoc) {
    // be lenient so Javadoc problems don't fail the whole publish
    failOnError = false

    // include Java + Kotlin sources (if Kotlin plugin present)
    def javaDirs = android.sourceSets.main.java.srcDirs
    def kotlinDirs = []
    try {
        kotlinDirs = android.sourceSets.main.kotlin.srcDirs
    } catch (ignored) {}
    source = files(javaDirs + kotlinDirs)

    // Android boot classpath
    classpath += files(android.getBootClasspath().join(File.pathSeparator))

    // Add the compile classpath for the release variant (provider-compatible)
    // Use variant provider API if available; otherwise fallback to older property
    android.libraryVariants.matching { it.name == 'release' }.all { variant ->
        if (variant.respondsTo('javaCompileProvider')) {
            classpath += variant.javaCompileProvider.get().classpath
        } else if (variant.respondsTo('javaCompile')) {
            classpath += variant.javaCompile.classpath
        }
    }

    options.encoding = 'UTF-8'
}

// Javadoc jar (registered but we'll conditionally add to publications)
tasks.register('androidJavadocsJar', Jar) {
    dependsOn tasks.named('androidJavadocs')
    archiveClassifier.set('javadoc')
    from tasks.named('androidJavadocs').get().destinationDir
}

// Sources jar
tasks.register('androidSourcesJar', Jar) {
    archiveClassifier.set('sources')
    def javaDirs = android.sourceSets.main.java.srcDirs
    def kotlinDirs = []
    try { kotlinDirs = android.sourceSets.main.kotlin.srcDirs } catch (ignored) {}
    from files(javaDirs + kotlinDirs)
}

/* --------- Publishing configuration (safe guards) ---------- */
project.afterEvaluate {
    publishing {
        publications {
            maven(MavenPublication) {
                groupId packageName
                artifactId appId
                version = libraryVersion

                // --- AAR artifact: prefer bundle task, else fallback to build dir (provider-friendly) ---
                def bundleTask = tasks.findByName('bundleReleaseAar')
                if (bundleTask != null) {
                    // try to use the task's archiveFile provider (works for modern bundle tasks)
                    try {
                        artifact(bundleTask.archiveFile)
                    } catch (Throwable ignored) {
                        // if the task doesn't expose archiveFile then fallback
                        artifact(layout.buildDirectory.file("outputs/aar/${project.name}-release.aar"))
                    }
                } else {
                    // fallback to layout.buildDirectory provider path
                    artifact(layout.buildDirectory.file("outputs/aar/${project.name}-release.aar"))
                }

                // Add sources jar
                artifact(tasks.named('androidSourcesJar').flatMap { it.archiveFile })

                // Add javadoc jar unless we are on JitPack (optional, prevents fragile Javadoc failures)
                if (!isJitpack) {
                    artifact(tasks.named('androidJavadocsJar').flatMap { it.archiveFile })
                }

                // Build POM dependencies safely:
                pom.withXml {
                    def dependenciesNode = asNode().appendNode('dependencies')

                    def addDependency = { dep, String scope ->
                        if (!dep || dep.group == null || dep.version == null || dep.name == null || dep.name == "unspecified") return
                        def dependencyNode = dependenciesNode.appendNode('dependency')
                        dependencyNode.appendNode('groupId', dep.group)
                        dependencyNode.appendNode('artifactId', dep.name)
                        dependencyNode.appendNode('version', dep.version)
                        dependencyNode.appendNode('scope', scope)

                        // transitive/exclude rules (guarded)
                        try {
                            if (!dep.transitive) {
                                def exclusionNode = dependencyNode.appendNode('exclusions').appendNode('exclusion')
                                exclusionNode.appendNode('groupId', '*')
                                exclusionNode.appendNode('artifactId', '*')
                            } else if (dep.properties?.excludeRules) {
                                dep.properties.excludeRules.each { ExcludeRule rule ->
                                    def exclusionNode = dependencyNode.appendNode('exclusions').appendNode('exclusion')
                                    exclusionNode.appendNode('groupId', rule.group ?: '*')
                                    exclusionNode.appendNode('artifactId', rule.module ?: '*')
                                }
                            }
                        } catch (ignored) {}
                    }

                    // iterate declared configurations if present (provider-friendly check)
                    ['api', 'implementation', 'compile', 'compileOnly', 'runtimeOnly'].each { confName ->
                        if (configurations.names.contains(confName)) {
                            configurations.named(confName).get().dependencies.each { dep ->
                                addDependency(dep, (confName == 'api' || confName == 'compile') ? 'compile' : 'runtime')
                            }
                        }
                    }
                }
            }
        }
    }
}

// Helpful notes for local testing:
// - Run: ./gradlew :library:assembleRelease :library:publishToMavenLocal --no-daemon
// - Check generated files in ~/.m2/repository/${packageName.replace('.', '/')}/${appId}/${libraryVersion}/
// - If using JitPack, add a jitpack.yml with `jdk: - openjdk17` to ensure Java 17 is used
